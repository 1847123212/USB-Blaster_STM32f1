; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\out\usb_istr.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\out\usb_istr.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\src -I..\usb -I..\drv -I..\sys -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -IC:\Work\WiDSO-master\MCU\USB-Blaster\MDK-ARM\RTE -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.0.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=517 -D_RTE_ -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD --omf_browse=.\out\usb_istr.crf ..\usb\usb_istr.c]
                          THUMB

                          AREA ||i.USB_Istr||, CODE, READONLY, ALIGN=2

                  USB_Istr PROC
;;;74     *******************************************************************************/
;;;75     void USB_Istr(void)
000000  b510              PUSH     {r4,lr}
;;;76     {
;;;77     #if (IMR_MSK & ISTR_ESOF)
;;;78         uint32_t i = 0;
;;;79     #endif
;;;80         __IO uint32_t EP[8];
;;;81     
;;;82         wIstr = _GetISTR();
000002  480f              LDR      r0,|L1.64|
000004  6800              LDR      r0,[r0,#0]
000006  490f              LDR      r1,|L1.68|
000008  8008              STRH     r0,[r1,#0]
;;;83     
;;;84     #if (IMR_MSK & ISTR_CTR)
;;;85         if (wIstr & ISTR_CTR & wInterrupt_Mask) {
00000a  4608              MOV      r0,r1
00000c  8800              LDRH     r0,[r0,#0]  ; wIstr
00000e  f4004000          AND      r0,r0,#0x8000
000012  490d              LDR      r1,|L1.72|
000014  8809              LDRH     r1,[r1,#0]  ; wInterrupt_Mask
000016  4008              ANDS     r0,r0,r1
000018  b108              CBZ      r0,|L1.30|
;;;86             /* servicing of the endpoint correct transfer interrupt */
;;;87             /* clear of the CTR flag into the sub */
;;;88             CTR_LP();
00001a  f7fffffe          BL       CTR_LP
                  |L1.30|
;;;89     #ifdef CTR_CALLBACK
;;;90             CTR_Callback();
;;;91     #endif
;;;92         }
;;;93     #endif
;;;94         
;;;95         /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;96     #if (IMR_MSK & ISTR_RESET)
;;;97         if (wIstr & ISTR_RESET & wInterrupt_Mask) {
00001e  4809              LDR      r0,|L1.68|
000020  8800              LDRH     r0,[r0,#0]  ; wIstr
000022  f4006080          AND      r0,r0,#0x400
000026  4908              LDR      r1,|L1.72|
000028  8809              LDRH     r1,[r1,#0]  ; wInterrupt_Mask
00002a  4008              ANDS     r0,r0,r1
00002c  b130              CBZ      r0,|L1.60|
;;;98             _SetISTR((uint16_t)CLR_RESET);
00002e  f64f30ff          MOV      r0,#0xfbff
000032  4903              LDR      r1,|L1.64|
000034  6008              STR      r0,[r1,#0]
;;;99             Device_Property.Reset();
000036  4905              LDR      r1,|L1.76|
000038  6848              LDR      r0,[r1,#4]  ; Device_Property
00003a  4780              BLX      r0
                  |L1.60|
;;;100    #ifdef RESET_CALLBACK
;;;101            RESET_Callback();
;;;102    #endif
;;;103        }
;;;104    #endif
;;;105        
;;;106        /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;107    #if (IMR_MSK & ISTR_DOVR)
;;;108        if (wIstr & ISTR_DOVR & wInterrupt_Mask) {
;;;109            _SetISTR((uint16_t)CLR_DOVR);
;;;110    #ifdef DOVR_CALLBACK
;;;111            DOVR_Callback();
;;;112    #endif
;;;113        }
;;;114    #endif
;;;115        
;;;116        /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;117    #if (IMR_MSK & ISTR_ERR)
;;;118        if (wIstr & ISTR_ERR & wInterrupt_Mask) {
;;;119            _SetISTR((uint16_t)CLR_ERR);
;;;120    #ifdef ERR_CALLBACK
;;;121            ERR_Callback();
;;;122    #endif
;;;123        }
;;;124    #endif
;;;125        
;;;126        /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;127    #if (IMR_MSK & ISTR_WKUP)
;;;128        if (wIstr & ISTR_WKUP & wInterrupt_Mask) {
;;;129            _SetISTR((uint16_t)CLR_WKUP);
;;;130            Resume(RESUME_EXTERNAL);
;;;131    #ifdef WKUP_CALLBACK
;;;132            WKUP_Callback();
;;;133    #endif
;;;134        }
;;;135    #endif
;;;136        
;;;137        /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;138    #if (IMR_MSK & ISTR_SUSP)
;;;139        if (wIstr & ISTR_SUSP & wInterrupt_Mask) {
;;;140            /* check if SUSPEND is possible */
;;;141            if (fSuspendEnabled) {
;;;142                Suspend();
;;;143            } else {
;;;144                /* if not possible then resume after xx ms */
;;;145                Resume(RESUME_LATER);
;;;146            }
;;;147            /* clear of the ISTR bit must be done after setting of CNTR_FSUSP */
;;;148            _SetISTR((uint16_t)CLR_SUSP);
;;;149    #ifdef SUSP_CALLBACK
;;;150            SUSP_Callback();
;;;151    #endif
;;;152        }
;;;153    #endif
;;;154        
;;;155        /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;156    #if (IMR_MSK & ISTR_SOF)
;;;157        if (wIstr & ISTR_SOF & wInterrupt_Mask) {
;;;158            _SetISTR((uint16_t)CLR_SOF);
;;;159            bIntPackSOF++;
;;;160    #ifdef SOF_CALLBACK
;;;161            SOF_Callback();
;;;162    #endif
;;;163        }
;;;164    #endif
;;;165        
;;;166        /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;167    #if (IMR_MSK & ISTR_ESOF)
;;;168        if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
;;;169            /* clear ESOF flag in ISTR */
;;;170            _SetISTR((uint16_t)CLR_ESOF);
;;;171    
;;;172            if ((_GetFNR()&FNR_RXDP) != 0) {
;;;173                /* increment ESOF counter */
;;;174                esof_counter ++;
;;;175    
;;;176                /* test if we enter in ESOF more than 3 times with FSUSP =0 and RXDP =1=>> possible missing SUSP flag*/
;;;177                if ((esof_counter > 3) && ((_GetCNTR()&CNTR_FSUSP) == 0)) {
;;;178                    /* this a sequence to apply a force RESET*/
;;;179    
;;;180                    /*Store CNTR value */
;;;181                    wCNTR = _GetCNTR();
;;;182    
;;;183                    /*Store endpoints registers status */
;;;184                    for (i = 0; i < 8; i++) {
;;;185                        EP[i] = _GetENDPOINT(i);
;;;186                    }
;;;187    
;;;188                    /*apply FRES */
;;;189                    wCNTR |= CNTR_FRES;
;;;190                    _SetCNTR(wCNTR);
;;;191    
;;;192                    /*clear FRES*/
;;;193                    wCNTR &= ~CNTR_FRES;
;;;194                    _SetCNTR(wCNTR);
;;;195    
;;;196                    /*poll for RESET flag in ISTR*/
;;;197                    while ((_GetISTR()&ISTR_RESET) == 0);
;;;198    
;;;199                    /* clear RESET flag in ISTR */
;;;200                    _SetISTR((uint16_t)CLR_RESET);
;;;201    
;;;202                    /*restore Enpoints*/
;;;203                    for (i = 0; i < 8; i++) {
;;;204                        _SetENDPOINT(i, EP[i]);
;;;205                    }
;;;206    
;;;207                    esof_counter = 0;
;;;208                }
;;;209            } else {
;;;210                esof_counter = 0;
;;;211            }
;;;212    
;;;213            /* resume handling timing is made with ESOFs */
;;;214            Resume(RESUME_ESOF); /* request without change of the machine state */
;;;215    
;;;216    #ifdef ESOF_CALLBACK
;;;217            ESOF_Callback();
;;;218    #endif
;;;219        }
;;;220    #endif
;;;221    } /* USB_Istr */
00003c  bd10              POP      {r4,pc}
;;;222    
                          ENDP

00003e  0000              DCW      0x0000
                  |L1.64|
                          DCD      0x40005c44
                  |L1.68|
                          DCD      wIstr
                  |L1.72|
                          DCD      wInterrupt_Mask
                  |L1.76|
                          DCD      Device_Property

                          AREA ||.data||, DATA, ALIGN=2

                  wIstr
000000  0000              DCB      0x00,0x00
                  bIntPackSOF
000002  0000              DCB      0x00,0x00
                  esof_counter
                          DCD      0x00000000
                  wCNTR
                          DCD      0x00000000
                  pEpInt_IN
                          DCD      EP1_IN_Callback
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                  pEpInt_OUT
                          DCD      NOP_Process
                          DCD      EP2_OUT_Callback
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process

;*** Start embedded assembler ***

#line 1 "..\\usb\\usb_istr.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_istr_c_e9471872____REV16|
#line 388 "D:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_usb_istr_c_e9471872____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_istr_c_e9471872____REVSH|
#line 402
|__asm___10_usb_istr_c_e9471872____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_istr_c_e9471872____RRX|
#line 587
|__asm___10_usb_istr_c_e9471872____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
