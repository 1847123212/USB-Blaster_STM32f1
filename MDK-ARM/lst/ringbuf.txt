; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\out\ringbuf.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\out\ringbuf.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\src -I..\usb -I..\drv -I..\sys -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -IC:\Work\WiDSO-master\MCU\USB-Blaster\MDK-ARM\RTE -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.0.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=517 -D_RTE_ -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD --omf_browse=.\out\ringbuf.crf ..\src\ringbuf.c]
                          THUMB

                          AREA ||i.ringbuf_get||, CODE, READONLY, ALIGN=1

                  ringbuf_get PROC
;;;62     // 从缓冲区中取数据
;;;63     u32 ringbuf_get(ringbuf_t *ring_buf, void *buffer, u32 size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;64     {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;65         u32 len = 0;
00000a  2700              MOVS     r7,#0
;;;66         
;;;67         size = MIN(size, ring_buf->in - ring_buf->out);
00000c  e9d40102          LDRD     r0,r1,[r4,#8]
000010  1a40              SUBS     r0,r0,r1
000012  42a8              CMP      r0,r5
000014  d301              BCC      |L1.26|
000016  4628              MOV      r0,r5
000018  e002              B        |L1.32|
                  |L1.26|
00001a  e9d40102          LDRD     r0,r1,[r4,#8]
00001e  1a40              SUBS     r0,r0,r1
                  |L1.32|
000020  4605              MOV      r5,r0
;;;68         /* first get the data from fifo->out until the end of the buffer */
;;;69         len = MIN(size, ring_buf->size - (ring_buf->out & (ring_buf->size - 1)));
000022  6861              LDR      r1,[r4,#4]
000024  1e49              SUBS     r1,r1,#1
000026  68e0              LDR      r0,[r4,#0xc]
000028  4008              ANDS     r0,r0,r1
00002a  6861              LDR      r1,[r4,#4]
00002c  1a08              SUBS     r0,r1,r0
00002e  42a8              CMP      r0,r5
000030  d301              BCC      |L1.54|
000032  4628              MOV      r0,r5
000034  e005              B        |L1.66|
                  |L1.54|
000036  6861              LDR      r1,[r4,#4]
000038  1e49              SUBS     r1,r1,#1
00003a  68e0              LDR      r0,[r4,#0xc]
00003c  4008              ANDS     r0,r0,r1
00003e  6861              LDR      r1,[r4,#4]
000040  1a08              SUBS     r0,r1,r0
                  |L1.66|
000042  4607              MOV      r7,r0
;;;70         memcpy((u8*)buffer, (u8*)ring_buf->buffer + (ring_buf->out & (ring_buf->size - 1)), len);
000044  6862              LDR      r2,[r4,#4]
000046  1e52              SUBS     r2,r2,#1
000048  68e0              LDR      r0,[r4,#0xc]
00004a  4010              ANDS     r0,r0,r2
00004c  6822              LDR      r2,[r4,#0]
00004e  1881              ADDS     r1,r0,r2
000050  463a              MOV      r2,r7
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       __aeabi_memcpy
;;;71         /* then get the rest (if any) from the beginning of the buffer */
;;;72         memcpy((u8*)buffer + len, (u8*)ring_buf->buffer, size - len);
000058  1bea              SUBS     r2,r5,r7
00005a  19f0              ADDS     r0,r6,r7
00005c  6821              LDR      r1,[r4,#0]
00005e  f7fffffe          BL       __aeabi_memcpy
;;;73         ring_buf->out += size;
000062  68e0              LDR      r0,[r4,#0xc]
000064  4428              ADD      r0,r0,r5
000066  60e0              STR      r0,[r4,#0xc]
;;;74         
;;;75         // buffer中没有数据
;;;76         if (ring_buf->in == ring_buf->out) {
000068  e9d40102          LDRD     r0,r1,[r4,#8]
00006c  4288              CMP      r0,r1
00006e  d102              BNE      |L1.118|
;;;77             ring_buf->in = ring_buf->out = 0;
000070  2000              MOVS     r0,#0
000072  60e0              STR      r0,[r4,#0xc]
000074  60a0              STR      r0,[r4,#8]
                  |L1.118|
;;;78         }
;;;79         
;;;80         return size;
000076  4628              MOV      r0,r5
;;;81     }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;82     
                          ENDP


                          AREA ||i.ringbuf_init||, CODE, READONLY, ALIGN=1

                  ringbuf_init PROC
;;;34     // 初始化缓冲区
;;;35     u32 ringbuf_init(ringbuf_t *ring_buf, void *buffer, u32 size)
000000  4603              MOV      r3,r0
;;;36     {
;;;37         if (!is_power_of_2(size)) {
000002  b112              CBZ      r2,|L2.10|
000004  1e50              SUBS     r0,r2,#1
000006  4010              ANDS     r0,r0,r2
000008  b108              CBZ      r0,|L2.14|
                  |L2.10|
;;;38             return FALSE;
00000a  2000              MOVS     r0,#0
                  |L2.12|
;;;39         }
;;;40         
;;;41         memset(ring_buf, 0, sizeof(ringbuf_t));
;;;42         ring_buf->buffer = buffer;
;;;43         ring_buf->size = size;
;;;44         ring_buf->in = 0;
;;;45         ring_buf->out = 0;
;;;46         
;;;47         return TRUE;
;;;48     }
00000c  4770              BX       lr
                  |L2.14|
00000e  2000              MOVS     r0,#0                 ;41
000010  6018              STR      r0,[r3,#0]            ;41
000012  6058              STR      r0,[r3,#4]            ;41
000014  6098              STR      r0,[r3,#8]            ;41
000016  60d8              STR      r0,[r3,#0xc]          ;41
000018  6019              STR      r1,[r3,#0]            ;42
00001a  605a              STR      r2,[r3,#4]            ;43
00001c  6098              STR      r0,[r3,#8]            ;44
00001e  60d8              STR      r0,[r3,#0xc]          ;45
000020  2001              MOVS     r0,#1                 ;47
000022  e7f3              B        |L2.12|
;;;49     
                          ENDP


                          AREA ||i.ringbuf_is_full||, CODE, READONLY, ALIGN=1

                  ringbuf_is_full PROC
;;;56     // 判断缓冲区是否满
;;;57     u32 ringbuf_is_full(const ringbuf_t *ring_buf)
000000  4601              MOV      r1,r0
;;;58     {
;;;59         return (ring_buf->in - ring_buf->out == ring_buf->size);
000002  e9d10202          LDRD     r0,r2,[r1,#8]
000006  1a80              SUBS     r0,r0,r2
000008  684a              LDR      r2,[r1,#4]
00000a  4290              CMP      r0,r2
00000c  d101              BNE      |L3.18|
00000e  2001              MOVS     r0,#1
                  |L3.16|
;;;60     }
000010  4770              BX       lr
                  |L3.18|
000012  2000              MOVS     r0,#0                 ;59
000014  e7fc              B        |L3.16|
;;;61     
                          ENDP


                          AREA ||i.ringbuf_put||, CODE, READONLY, ALIGN=1

                  ringbuf_put PROC
;;;83     // 向缓冲区中存数据
;;;84     u32 ringbuf_put(ringbuf_t *ring_buf, const void *buffer, u32 size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;85     {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;86         u32 len = 0;
00000a  2600              MOVS     r6,#0
;;;87         
;;;88         size = MIN(size, ring_buf->size - ring_buf->in + ring_buf->out);
00000c  e9d40101          LDRD     r0,r1,[r4,#4]
000010  1a40              SUBS     r0,r0,r1
000012  68e1              LDR      r1,[r4,#0xc]
000014  4408              ADD      r0,r0,r1
000016  42a8              CMP      r0,r5
000018  d301              BCC      |L4.30|
00001a  4628              MOV      r0,r5
00001c  e004              B        |L4.40|
                  |L4.30|
00001e  e9d40101          LDRD     r0,r1,[r4,#4]
000022  1a40              SUBS     r0,r0,r1
000024  68e1              LDR      r1,[r4,#0xc]
000026  4408              ADD      r0,r0,r1
                  |L4.40|
000028  4605              MOV      r5,r0
;;;89         /* first put the data starting from fifo->in to buffer end */
;;;90         len  = MIN(size, ring_buf->size - (ring_buf->in & (ring_buf->size - 1)));
00002a  e9d41001          LDRD     r1,r0,[r4,#4]
00002e  1e49              SUBS     r1,r1,#1
000030  4008              ANDS     r0,r0,r1
000032  6861              LDR      r1,[r4,#4]
000034  1a08              SUBS     r0,r1,r0
000036  42a8              CMP      r0,r5
000038  d301              BCC      |L4.62|
00003a  4628              MOV      r0,r5
00003c  e005              B        |L4.74|
                  |L4.62|
00003e  e9d41001          LDRD     r1,r0,[r4,#4]
000042  1e49              SUBS     r1,r1,#1
000044  4008              ANDS     r0,r0,r1
000046  6861              LDR      r1,[r4,#4]
000048  1a08              SUBS     r0,r1,r0
                  |L4.74|
00004a  4606              MOV      r6,r0
;;;91         memcpy((u8*)ring_buf->buffer + (ring_buf->in & (ring_buf->size - 1)), (u8*)buffer, len);
00004c  e9d42101          LDRD     r2,r1,[r4,#4]
000050  1e52              SUBS     r2,r2,#1
000052  4011              ANDS     r1,r1,r2
000054  6822              LDR      r2,[r4,#0]
000056  1888              ADDS     r0,r1,r2
000058  4632              MOV      r2,r6
00005a  4639              MOV      r1,r7
00005c  f7fffffe          BL       __aeabi_memcpy
;;;92         /* then put the rest (if any) at the beginning of the buffer */
;;;93         memcpy((u8*)ring_buf->buffer, (u8*)buffer + len, size - len);
000060  1baa              SUBS     r2,r5,r6
000062  19b9              ADDS     r1,r7,r6
000064  6820              LDR      r0,[r4,#0]
000066  f7fffffe          BL       __aeabi_memcpy
;;;94         ring_buf->in += size;
00006a  68a0              LDR      r0,[r4,#8]
00006c  4428              ADD      r0,r0,r5
00006e  60a0              STR      r0,[r4,#8]
;;;95         
;;;96         return size;
000070  4628              MOV      r0,r5
;;;97     }
000072  e8bd81f0          POP      {r4-r8,pc}
;;;98     
                          ENDP


                          AREA ||i.ringbuf_putc||, CODE, READONLY, ALIGN=1

                  ringbuf_putc PROC
;;;99     // 向缓冲区中存字节数据
;;;100    u32 ringbuf_putc(ringbuf_t *ring_buf, const u8 c)
000000  b510              PUSH     {r4,lr}
;;;101    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;102        if (ringbuf_is_full(ring_buf)) {
000006  4618              MOV      r0,r3
000008  f7fffffe          BL       ringbuf_is_full
00000c  b108              CBZ      r0,|L5.18|
;;;103            return 0;
00000e  2000              MOVS     r0,#0
                  |L5.16|
;;;104        }
;;;105    
;;;106        *((u8*)ring_buf->buffer + (ring_buf->in & (ring_buf->size - 1))) = c;
;;;107        ring_buf->in++;
;;;108        
;;;109        return 1;
;;;110    }
000010  bd10              POP      {r4,pc}
                  |L5.18|
000012  e9d31001          LDRD     r1,r0,[r3,#4]         ;106
000016  1e49              SUBS     r1,r1,#1              ;106
000018  4008              ANDS     r0,r0,r1              ;106
00001a  6819              LDR      r1,[r3,#0]            ;106
00001c  540c              STRB     r4,[r1,r0]            ;106
00001e  6898              LDR      r0,[r3,#8]            ;107
000020  1c40              ADDS     r0,r0,#1              ;107
000022  6098              STR      r0,[r3,#8]            ;107
000024  2001              MOVS     r0,#1                 ;109
000026  e7f3              B        |L5.16|
                          ENDP


                          AREA ||i.ringbuf_use_len||, CODE, READONLY, ALIGN=1

                  ringbuf_use_len PROC
;;;50     // 缓冲区数据的长度
;;;51     u32 ringbuf_use_len(const ringbuf_t *ring_buf)
000000  4601              MOV      r1,r0
;;;52     {
;;;53         return (ring_buf->in - ring_buf->out);
000002  e9d10202          LDRD     r0,r2,[r1,#8]
000006  1a80              SUBS     r0,r0,r2
;;;54     }
000008  4770              BX       lr
;;;55     
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\src\\ringbuf.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_ringbuf_c_c0517e68____REV16|
#line 388 "D:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_ringbuf_c_c0517e68____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_ringbuf_c_c0517e68____REVSH|
#line 402
|__asm___9_ringbuf_c_c0517e68____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_ringbuf_c_c0517e68____RRX|
#line 587
|__asm___9_ringbuf_c_c0517e68____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
