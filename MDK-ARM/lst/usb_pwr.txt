; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\out\usb_pwr.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\out\usb_pwr.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\src -I..\usb -I..\drv -I..\sys -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -IC:\Work\WiDSO-master\MCU\USB-Blaster\MDK-ARM\RTE -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.0.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=517 -D_RTE_ -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD --omf_browse=.\out\usb_pwr.crf ..\usb\usb_pwr.c]
                          THUMB

                          AREA ||i.PowerOff||, CODE, READONLY, ALIGN=2

                  PowerOff PROC
;;;90     *******************************************************************************/
;;;91     RESULT PowerOff()
000000  b510              PUSH     {r4,lr}
;;;92     {
;;;93         /* disable all interrupts and force USB reset */
;;;94         _SetCNTR(CNTR_FRES);
000002  2001              MOVS     r0,#1
000004  4905              LDR      r1,|L1.28|
000006  6008              STR      r0,[r1,#0]
;;;95         /* clear interrupt status register */
;;;96         _SetISTR(0);
000008  2000              MOVS     r0,#0
00000a  1d09              ADDS     r1,r1,#4
00000c  6008              STR      r0,[r1,#0]
;;;97         /* Disable the Pull-Up*/
;;;98         USB_Cable_Ctrl(DISABLE);
00000e  f7fffffe          BL       USB_Cable_Ctrl
;;;99         /* switch-off device */
;;;100        _SetCNTR(CNTR_FRES + CNTR_PDWN);
000012  2003              MOVS     r0,#3
000014  4901              LDR      r1,|L1.28|
000016  6008              STR      r0,[r1,#0]
;;;101        /* sw variables reset */
;;;102        /* ... */
;;;103    
;;;104        return USB_SUCCESS;
000018  2000              MOVS     r0,#0
;;;105    }
00001a  bd10              POP      {r4,pc}
;;;106    
                          ENDP

                  |L1.28|
                          DCD      0x40005c40

                          AREA ||i.PowerOn||, CODE, READONLY, ALIGN=2

                  PowerOn PROC
;;;60     *******************************************************************************/
;;;61     RESULT PowerOn(void)
000000  b510              PUSH     {r4,lr}
;;;62     {
;;;63         uint16_t wRegVal;
;;;64     
;;;65         /*** cable plugged-in ? ***/
;;;66         USB_Cable_Ctrl(ENABLE);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       USB_Cable_Ctrl
;;;67     
;;;68         /*** CNTR_PWDN = 0 ***/
;;;69         wRegVal = CNTR_FRES;
000008  2401              MOVS     r4,#1
;;;70         _SetCNTR(wRegVal);
00000a  480b              LDR      r0,|L2.56|
00000c  6004              STR      r4,[r0,#0]
;;;71     
;;;72         /*** CNTR_FRES = 0 ***/
;;;73         wInterrupt_Mask = 0;
00000e  2000              MOVS     r0,#0
000010  490a              LDR      r1,|L2.60|
000012  8008              STRH     r0,[r1,#0]
;;;74         _SetCNTR(wInterrupt_Mask);
000014  4608              MOV      r0,r1
000016  8800              LDRH     r0,[r0,#0]  ; wInterrupt_Mask
000018  4907              LDR      r1,|L2.56|
00001a  6008              STR      r0,[r1,#0]
;;;75         /*** Clear pending interrupts ***/
;;;76         _SetISTR(0);
00001c  2000              MOVS     r0,#0
00001e  1d09              ADDS     r1,r1,#4
000020  6008              STR      r0,[r1,#0]
;;;77         /*** Set interrupt mask ***/
;;;78         wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM;
000022  f44f50e0          MOV      r0,#0x1c00
000026  4905              LDR      r1,|L2.60|
000028  8008              STRH     r0,[r1,#0]
;;;79         _SetCNTR(wInterrupt_Mask);
00002a  4608              MOV      r0,r1
00002c  8800              LDRH     r0,[r0,#0]  ; wInterrupt_Mask
00002e  4902              LDR      r1,|L2.56|
000030  6008              STR      r0,[r1,#0]
;;;80     
;;;81         return USB_SUCCESS;
000032  2000              MOVS     r0,#0
;;;82     }
000034  bd10              POP      {r4,pc}
;;;83     
                          ENDP

000036  0000              DCW      0x0000
                  |L2.56|
                          DCD      0x40005c40
                  |L2.60|
                          DCD      wInterrupt_Mask

                          AREA ||i.Resume||, CODE, READONLY, ALIGN=2

                  Resume PROC
;;;254    *******************************************************************************/
;;;255    void Resume(RESUME_STATE eResumeSetVal)
000000  b570              PUSH     {r4-r6,lr}
;;;256    {
000002  4605              MOV      r5,r0
;;;257        uint16_t wCNTR;
;;;258    
;;;259        if (eResumeSetVal != RESUME_ESOF) {
000004  2d07              CMP      r5,#7
000006  d001              BEQ      |L3.12|
;;;260            ResumeS.eState = eResumeSetVal;
000008  482e              LDR      r0,|L3.196|
00000a  7005              STRB     r5,[r0,#0]
                  |L3.12|
;;;261        }
;;;262        switch (ResumeS.eState) {
00000c  482d              LDR      r0,|L3.196|
00000e  7800              LDRB     r0,[r0,#0]  ; ResumeS
000010  2808              CMP      r0,#8
000012  d24e              BCS      |L3.178|
000014  e8dff000          TBB      [pc,r0]
000018  04111a20          DCB      0x04,0x11,0x1a,0x20
00001c  2b384e4f          DCB      0x2b,0x38,0x4e,0x4f
;;;263        case RESUME_EXTERNAL:
;;;264            if (remotewakeupon == 0) {
000020  4829              LDR      r0,|L3.200|
000022  6800              LDR      r0,[r0,#0]  ; remotewakeupon
000024  b928              CBNZ     r0,|L3.50|
;;;265                Resume_Init();
000026  f7fffffe          BL       Resume_Init
;;;266                ResumeS.eState = RESUME_OFF;
00002a  2006              MOVS     r0,#6
00002c  4925              LDR      r1,|L3.196|
00002e  7008              STRB     r0,[r1,#0]
000030  e002              B        |L3.56|
                  |L3.50|
;;;267            } else { /* RESUME detected during the RemoteWAkeup signalling => keep RemoteWakeup handling*/
;;;268                ResumeS.eState = RESUME_ON;
000032  2005              MOVS     r0,#5
000034  4923              LDR      r1,|L3.196|
000036  7008              STRB     r0,[r1,#0]
                  |L3.56|
;;;269            }
;;;270            break;
000038  e041              B        |L3.190|
;;;271        case RESUME_INTERNAL:
;;;272            Resume_Init();
00003a  f7fffffe          BL       Resume_Init
;;;273            ResumeS.eState = RESUME_START;
00003e  2004              MOVS     r0,#4
000040  4920              LDR      r1,|L3.196|
000042  7008              STRB     r0,[r1,#0]
;;;274            remotewakeupon = 1;
000044  2001              MOVS     r0,#1
000046  4920              LDR      r1,|L3.200|
000048  6008              STR      r0,[r1,#0]  ; remotewakeupon
;;;275            break;
00004a  e038              B        |L3.190|
;;;276        case RESUME_LATER:
;;;277            ResumeS.bESOFcnt = 2;
00004c  2002              MOVS     r0,#2
00004e  491d              LDR      r1,|L3.196|
000050  7048              STRB     r0,[r1,#1]
;;;278            ResumeS.eState = RESUME_WAIT;
000052  2003              MOVS     r0,#3
000054  7008              STRB     r0,[r1,#0]
;;;279            break;
000056  e032              B        |L3.190|
;;;280        case RESUME_WAIT:
;;;281            ResumeS.bESOFcnt--;
000058  481a              LDR      r0,|L3.196|
00005a  7840              LDRB     r0,[r0,#1]  ; ResumeS
00005c  1e40              SUBS     r0,r0,#1
00005e  4919              LDR      r1,|L3.196|
000060  7048              STRB     r0,[r1,#1]
;;;282            if (ResumeS.bESOFcnt == 0) {
000062  4608              MOV      r0,r1
000064  7840              LDRB     r0,[r0,#1]  ; ResumeS
000066  b908              CBNZ     r0,|L3.108|
;;;283                ResumeS.eState = RESUME_START;
000068  2004              MOVS     r0,#4
00006a  7008              STRB     r0,[r1,#0]
                  |L3.108|
;;;284            }
;;;285            break;
00006c  e027              B        |L3.190|
;;;286        case RESUME_START:
;;;287            wCNTR = _GetCNTR();
00006e  4817              LDR      r0,|L3.204|
000070  6800              LDR      r0,[r0,#0]
000072  b284              UXTH     r4,r0
;;;288            wCNTR |= CNTR_RESUME;
000074  f0440410          ORR      r4,r4,#0x10
;;;289            _SetCNTR(wCNTR);
000078  4814              LDR      r0,|L3.204|
00007a  6004              STR      r4,[r0,#0]
;;;290            ResumeS.eState = RESUME_ON;
00007c  2005              MOVS     r0,#5
00007e  4911              LDR      r1,|L3.196|
000080  7008              STRB     r0,[r1,#0]
;;;291            ResumeS.bESOFcnt = 10;
000082  200a              MOVS     r0,#0xa
000084  7048              STRB     r0,[r1,#1]
;;;292            break;
000086  e01a              B        |L3.190|
;;;293        case RESUME_ON:
;;;294            ResumeS.bESOFcnt--;
000088  480e              LDR      r0,|L3.196|
00008a  7840              LDRB     r0,[r0,#1]  ; ResumeS
00008c  1e40              SUBS     r0,r0,#1
00008e  490d              LDR      r1,|L3.196|
000090  7048              STRB     r0,[r1,#1]
;;;295            if (ResumeS.bESOFcnt == 0) {
000092  4608              MOV      r0,r1
000094  7840              LDRB     r0,[r0,#1]  ; ResumeS
000096  b958              CBNZ     r0,|L3.176|
;;;296                wCNTR = _GetCNTR();
000098  480c              LDR      r0,|L3.204|
00009a  6800              LDR      r0,[r0,#0]
00009c  b284              UXTH     r4,r0
;;;297                wCNTR &= (~CNTR_RESUME);
00009e  f0240410          BIC      r4,r4,#0x10
;;;298                _SetCNTR(wCNTR);
0000a2  480a              LDR      r0,|L3.204|
0000a4  6004              STR      r4,[r0,#0]
;;;299                ResumeS.eState = RESUME_OFF;
0000a6  2006              MOVS     r0,#6
0000a8  7008              STRB     r0,[r1,#0]
;;;300                remotewakeupon = 0;
0000aa  2000              MOVS     r0,#0
0000ac  4906              LDR      r1,|L3.200|
0000ae  6008              STR      r0,[r1,#0]  ; remotewakeupon
                  |L3.176|
;;;301            }
;;;302            break;
0000b0  e005              B        |L3.190|
                  |L3.178|
;;;303        case RESUME_OFF:
0000b2  bf00              NOP      
;;;304        case RESUME_ESOF:
0000b4  bf00              NOP      
;;;305        default:
;;;306            ResumeS.eState = RESUME_OFF;
0000b6  2006              MOVS     r0,#6
0000b8  4902              LDR      r1,|L3.196|
0000ba  7008              STRB     r0,[r1,#0]
;;;307            break;
0000bc  bf00              NOP      
                  |L3.190|
0000be  bf00              NOP                            ;270
;;;308        }
;;;309    }
0000c0  bd70              POP      {r4-r6,pc}
;;;310    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L3.196|
                          DCD      ResumeS
                  |L3.200|
                          DCD      remotewakeupon
                  |L3.204|
                          DCD      0x40005c40

                          AREA ||i.Resume_Init||, CODE, READONLY, ALIGN=2

                  Resume_Init PROC
;;;218    *******************************************************************************/
;;;219    void Resume_Init(void)
000000  b510              PUSH     {r4,lr}
;;;220    {
;;;221        uint16_t wCNTR;
;;;222    
;;;223        /* ------------------ ONLY WITH BUS-POWERED DEVICES ---------------------- */
;;;224        /* restart the clocks */
;;;225        /* ...  */
;;;226    
;;;227        /* CNTR_LPMODE = 0 */
;;;228        wCNTR = _GetCNTR();
000002  4807              LDR      r0,|L4.32|
000004  6800              LDR      r0,[r0,#0]
000006  b284              UXTH     r4,r0
;;;229        wCNTR &= (~CNTR_LPMODE);
000008  f0240404          BIC      r4,r4,#4
;;;230        _SetCNTR(wCNTR);
00000c  4804              LDR      r0,|L4.32|
00000e  6004              STR      r4,[r0,#0]
;;;231    
;;;232        /* restore full power */
;;;233        /* ... on connected devices */
;;;234        Leave_LowPowerMode();
000010  f7fffffe          BL       Leave_LowPowerMode
;;;235    
;;;236        /* reset FSUSP bit */
;;;237        _SetCNTR(IMR_MSK);
000014  f44f4004          MOV      r0,#0x8400
000018  4901              LDR      r1,|L4.32|
00001a  6008              STR      r0,[r1,#0]
;;;238    
;;;239        /* reverse suspend preparation */
;;;240        /* ... */
;;;241    }
00001c  bd10              POP      {r4,pc}
;;;242    
                          ENDP

00001e  0000              DCW      0x0000
                  |L4.32|
                          DCD      0x40005c40

                          AREA ||i.Suspend||, CODE, READONLY, ALIGN=2

                  Suspend PROC
;;;113    *******************************************************************************/
;;;114    void Suspend(void)
000000  b538              PUSH     {r3-r5,lr}
;;;115    {
;;;116        uint32_t i = 0;
000002  2100              MOVS     r1,#0
;;;117        uint16_t wCNTR;
;;;118        uint32_t tmpreg = 0;
000004  2200              MOVS     r2,#0
;;;119        __IO uint32_t savePWR_CR = 0;
000006  2300              MOVS     r3,#0
000008  9300              STR      r3,[sp,#0]
;;;120        /* suspend preparation */
;;;121        /* ... */
;;;122    
;;;123        /*Store CNTR value */
;;;124        wCNTR = _GetCNTR();
00000a  4b39              LDR      r3,|L5.240|
00000c  681b              LDR      r3,[r3,#0]
00000e  b298              UXTH     r0,r3
;;;125    
;;;126        /* This a sequence to apply a force RESET to handle a robustness case */
;;;127    
;;;128        /*Store endpoints registers status */
;;;129        for (i = 0; i < 8; i++) {
000010  bf00              NOP      
000012  e009              B        |L5.40|
                  |L5.20|
;;;130            EP[i] = _GetENDPOINT(i);
000014  4c37              LDR      r4,|L5.244|
000016  eb040381          ADD      r3,r4,r1,LSL #2
00001a  f8d33c00          LDR      r3,[r3,#0xc00]
00001e  b29b              UXTH     r3,r3
000020  4c35              LDR      r4,|L5.248|
000022  f8443021          STR      r3,[r4,r1,LSL #2]
000026  1c49              ADDS     r1,r1,#1              ;129
                  |L5.40|
000028  2908              CMP      r1,#8                 ;129
00002a  d3f3              BCC      |L5.20|
;;;131        }
;;;132    
;;;133        /* unmask RESET flag */
;;;134        wCNTR |= CNTR_RESETM;
00002c  f4406080          ORR      r0,r0,#0x400
;;;135        _SetCNTR(wCNTR);
000030  4b2f              LDR      r3,|L5.240|
000032  6018              STR      r0,[r3,#0]
;;;136    
;;;137        /*apply FRES */
;;;138        wCNTR |= CNTR_FRES;
000034  f0400001          ORR      r0,r0,#1
;;;139        _SetCNTR(wCNTR);
000038  6018              STR      r0,[r3,#0]
;;;140    
;;;141        /*clear FRES*/
;;;142        wCNTR &= ~CNTR_FRES;
00003a  f0200001          BIC      r0,r0,#1
;;;143        _SetCNTR(wCNTR);
00003e  6018              STR      r0,[r3,#0]
;;;144    
;;;145        /*poll for RESET flag in ISTR*/
;;;146        while ((_GetISTR()&ISTR_RESET) == 0);
000040  bf00              NOP      
                  |L5.66|
000042  4b2b              LDR      r3,|L5.240|
000044  1d1b              ADDS     r3,r3,#4
000046  681b              LDR      r3,[r3,#0]
000048  f4036380          AND      r3,r3,#0x400
00004c  2b00              CMP      r3,#0
00004e  d0f8              BEQ      |L5.66|
;;;147    
;;;148        /* clear RESET flag in ISTR */
;;;149        _SetISTR((uint16_t)CLR_RESET);
000050  f64f33ff          MOV      r3,#0xfbff
000054  4c26              LDR      r4,|L5.240|
000056  1d24              ADDS     r4,r4,#4
000058  6023              STR      r3,[r4,#0]
;;;150    
;;;151        /*restore Enpoints*/
;;;152        for (i = 0; i < 8; i++) {
00005a  2100              MOVS     r1,#0
00005c  e009              B        |L5.114|
                  |L5.94|
;;;153            _SetENDPOINT(i, EP[i]);
00005e  4b26              LDR      r3,|L5.248|
000060  f8533021          LDR      r3,[r3,r1,LSL #2]
000064  b29b              UXTH     r3,r3
000066  4d23              LDR      r5,|L5.244|
000068  eb050481          ADD      r4,r5,r1,LSL #2
00006c  f8c43c00          STR      r3,[r4,#0xc00]
000070  1c49              ADDS     r1,r1,#1              ;152
                  |L5.114|
000072  2908              CMP      r1,#8                 ;152
000074  d3f3              BCC      |L5.94|
;;;154        }
;;;155    
;;;156        /* Now it is safe to enter macrocell in suspend mode */
;;;157        wCNTR |= CNTR_FSUSP;
000076  f0400008          ORR      r0,r0,#8
;;;158        _SetCNTR(wCNTR);
00007a  4b1d              LDR      r3,|L5.240|
00007c  6018              STR      r0,[r3,#0]
;;;159    
;;;160        /* force low-power mode in the macrocell */
;;;161        wCNTR = _GetCNTR();
00007e  681b              LDR      r3,[r3,#0]
000080  b298              UXTH     r0,r3
;;;162        wCNTR |= CNTR_LPMODE;
000082  f0400004          ORR      r0,r0,#4
;;;163        _SetCNTR(wCNTR);
000086  4b1a              LDR      r3,|L5.240|
000088  6018              STR      r0,[r3,#0]
;;;164    
;;;165        /*prepare entry in low power mode (STOP mode)*/
;;;166        /* Select the regulator state in STOP mode*/
;;;167        savePWR_CR = PWR->CR;
00008a  4b1c              LDR      r3,|L5.252|
00008c  681b              LDR      r3,[r3,#0]
00008e  9300              STR      r3,[sp,#0]
;;;168        tmpreg = PWR->CR;
000090  4b1a              LDR      r3,|L5.252|
000092  681a              LDR      r2,[r3,#0]
;;;169        /* Clear PDDS and LPDS bits */
;;;170        tmpreg &= ((uint32_t)0xFFFFFFFC);
000094  f0220203          BIC      r2,r2,#3
;;;171        /* Set LPDS bit according to PWR_Regulator value */
;;;172        tmpreg |= PWR_Regulator_LowPower;
000098  f0420201          ORR      r2,r2,#1
;;;173        /* Store the new value */
;;;174        PWR->CR = tmpreg;
00009c  601a              STR      r2,[r3,#0]
;;;175        /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;176    #if defined (STM32F30X) || defined (STM32F37X)
;;;177        SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
;;;178    #else
;;;179        SCB->SCR |= SCB_SCR_SLEEPDEEP;
00009e  4b18              LDR      r3,|L5.256|
0000a0  681b              LDR      r3,[r3,#0]
0000a2  f0430304          ORR      r3,r3,#4
0000a6  4c16              LDR      r4,|L5.256|
0000a8  6023              STR      r3,[r4,#0]
;;;180    #endif
;;;181    
;;;182        /* enter system in STOP mode, only when wakeup flag in not set */
;;;183        if ((_GetISTR()&ISTR_WKUP) == 0) {
0000aa  4b11              LDR      r3,|L5.240|
0000ac  1d1b              ADDS     r3,r3,#4
0000ae  681b              LDR      r3,[r3,#0]
0000b0  f4035380          AND      r3,r3,#0x1000
0000b4  b933              CBNZ     r3,|L5.196|
;;;184            __WFI();
0000b6  bf30              WFI      
;;;185            /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;186    #if defined (STM32F30X) || defined (STM32F37X)
;;;187            SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
;;;188    #else
;;;189            SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP);
0000b8  4623              MOV      r3,r4
0000ba  681b              LDR      r3,[r3,#0]
0000bc  f0230304          BIC      r3,r3,#4
0000c0  6023              STR      r3,[r4,#0]
0000c2  e014              B        |L5.238|
                  |L5.196|
;;;190    #endif
;;;191        } else {
;;;192            /* Clear Wakeup flag */
;;;193            _SetISTR(CLR_WKUP);
0000c4  f64e73ff          MOV      r3,#0xefff
0000c8  4c09              LDR      r4,|L5.240|
0000ca  1d24              ADDS     r4,r4,#4
0000cc  6023              STR      r3,[r4,#0]
;;;194            /* clear FSUSP to abort entry in suspend mode  */
;;;195            wCNTR = _GetCNTR();
0000ce  1f23              SUBS     r3,r4,#4
0000d0  681b              LDR      r3,[r3,#0]
0000d2  b298              UXTH     r0,r3
;;;196            wCNTR &= ~CNTR_FSUSP;
0000d4  f0200008          BIC      r0,r0,#8
;;;197            _SetCNTR(wCNTR);
0000d8  1f23              SUBS     r3,r4,#4
0000da  6018              STR      r0,[r3,#0]
;;;198    
;;;199            /*restore sleep mode configuration */
;;;200            /* restore Power regulator config in sleep mode*/
;;;201            PWR->CR = savePWR_CR;
0000dc  4c07              LDR      r4,|L5.252|
0000de  9b00              LDR      r3,[sp,#0]
0000e0  6023              STR      r3,[r4,#0]
;;;202    
;;;203            /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;204    #if defined (STM32F30X) || defined (STM32F37X)
;;;205            SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
;;;206    #else
;;;207            SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP);
0000e2  4b07              LDR      r3,|L5.256|
0000e4  681b              LDR      r3,[r3,#0]
0000e6  f0230304          BIC      r3,r3,#4
0000ea  4c05              LDR      r4,|L5.256|
0000ec  6023              STR      r3,[r4,#0]
                  |L5.238|
;;;208    #endif
;;;209        }
;;;210    }
0000ee  bd38              POP      {r3-r5,pc}
;;;211    
                          ENDP

                  |L5.240|
                          DCD      0x40005c40
                  |L5.244|
                          DCD      0x40005000
                  |L5.248|
                          DCD      ||EP||
                  |L5.252|
                          DCD      0x40007000
                  |L5.256|
                          DCD      0xe000ed10

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ||EP||
                          %        32

                          AREA ||.data||, DATA, ALIGN=2

                  bDeviceState
                          DCD      0x00000000
                  fSuspendEnabled
000004  00                DCB      0x00
                  ResumeS
000005  000000            DCB      0x00,0x00,0x00
                  remotewakeupon
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\usb\\usb_pwr.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_usb_pwr_c_e4e9521d____REV16|
#line 388 "D:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_usb_pwr_c_e4e9521d____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_usb_pwr_c_e4e9521d____REVSH|
#line 402
|__asm___9_usb_pwr_c_e4e9521d____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_usb_pwr_c_e4e9521d____RRX|
#line 587
|__asm___9_usb_pwr_c_e4e9521d____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
